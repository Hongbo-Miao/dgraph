package main

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"log"
	"os"
	"regexp"
	"strconv"
	"time"

	"github.com/dgraph-io/dgo/v210"
	"github.com/dgraph-io/dgo/v210/protos/api"
	"google.golang.org/grpc"
)

var (
	isQuery = regexp.MustCompile(`Got a query: query:(.*)`)
	queryRe = regexp.MustCompile(`".*?"`)
	varRe   = regexp.MustCompile(`vars:<.*?>`)
	keyRe   = regexp.MustCompile(`key:(".*?")`)
	valRe   = regexp.MustCompile(`value:(".*?")`)
)

func main() {
	filePath := flag.String("file", "", "Path of the log file")
	alpha := flag.String("alpha", "localhost:9080", "GRPC endpoint of alpha")
	flag.Parse()

	f, err := os.Open(*filePath)
	if err != nil {
		log.Fatalf("While opening log file got error: %v", err)
	}
	defer f.Close()

	conn, err := grpc.Dial(*alpha, grpc.WithInsecure())
	if err != nil {
		log.Fatalf("While dialing grpc: %v\n", err)
	}
	defer conn.Close()
	dc := dgo.NewDgraphClient(api.NewDgraphClient(conn))

	qq := `query Node($sessionCount: int) {
		qq(func: eq(player_id, UeIiqRSv3vRJdn3pmKJobZ6y6JY2)) {
			player_id
			session(first: $sessionCount){
				uid
			}
		}
	}`
	resp := runQuery(&api.Request{Query: qq}, dc)
	fmt.Println(resp)
	// scan := bufio.NewScanner(f)
	// for scan.Scan() {
	// 	line := scan.Text()
	// 	r := getReq(line)
	// 	if r != nil {
	// 		resp := runQuery(r, dc)
	// 		fmt.Println(resp)
	// 	}
	// 	time.Sleep(1 * time.Second)
	// }
}

func getReq(s string) *api.Request {
	m := isQuery.FindStringSubmatch(s)
	if len(m) > 1 {
		qm := queryRe.FindStringSubmatch(m[1])
		if len(qm) == 0 {
			return nil
		}
		// query := qm[0]
		query, err := strconv.Unquote(qm[0])
		if err != nil {
			log.Printf("[ERR] While unquoting query: %v\n", err)
		}
		varStr := varRe.FindAllStringSubmatch(m[1], -1)
		mp := make(map[string]string)
		for _, v := range varStr {
			keys := keyRe.FindStringSubmatch(v[0])
			vals := valRe.FindStringSubmatch(v[0])
			mp[keys[1]] = vals[1]
		}
		return &api.Request{
			Query: query,
			Vars:  mp,
		}
	}
	return nil
}

func runQuery(r *api.Request, client *dgo.Dgraph) string {
	fmt.Printf("Processing Query: %s vars: %+v\n", r.Query, r.Vars)
	txn := client.NewReadOnlyTxn().BestEffort()
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	resp, err := txn.QueryWithVars(ctx, r.Query, r.Vars)
	if err != nil {
		log.Fatalf("Got error while running %s \n%+v \n%v\n", r.Query, r.Vars, err)
	}
	return string(resp.Json)
}
